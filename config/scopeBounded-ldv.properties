# Configuration for scope-bounded verification
# Base configuration (similar to LDV)

analysis.algorithm.CEGAR = true
analysis.checkCounterexamples = false
analysis.functionPointerCalls = true
analysis.machineModel = Linux64
analysis.summaryEdges = true
analysis.traversal.order = bfs
analysis.traversal.useCallstack = true
analysis.traversal.useReversePostorder = true

# (!!!) VVV
ScopeBoundedCPA.cpa = cpa.arg.ARGCPA
ARGCPA.cpa = cpa.composite.CompositeCPA

cegar.refiner = cpa.scopebounded.ScopeBoundedRefiner
# (!!!) ^^^

cfa.export = false
cfa.showDeadCode = false

CompositeCPA.cpas = cpa.location.LocationCPA, cpa.callstack.CallstackCPA, cpa.functionpointer.FunctionPointerCPA, cpa.predicate.PredicateCPA, cpa.conditions.path.PathConditionsCPA

counterexample.checker = CPACHECKER
counterexample.checker.config = ../cex-checks/predicateAnalysis-as-bitprecise-cex-check.properties
counterexample.export.file = ErrorPath.txt

# (!!!) VVV
cpa = cpa.scopebounded.ScopeBoundedCPA
# (!!!) ^^^

cpa.arg.export = false
cpa.arg.witness.removeInsufficientEdges = false

cpa.callstack.skipRecursion = true

cpa.composite.aggregateBasicBlocks = true

cpa.conditions.path.assignments.threshold = 22
cpa.conditions.path.condition = AssignmentsInPathCondition

cpa.functionpointer.ignoreUnknownFunctionPointerCalls = true

cpa.predicate.blk.alwaysAtFunctions = false
cpa.predicate.blk.alwaysAtLoops = true
cpa.predicate.defaultArrayLength = 1
cpa.predicate.handlePointerAliasing = true
cpa.predicate.maxArrayLength = 1
cpa.predicate.memoryAllocationsAlwaysSucceed = false
cpa.predicate.nondetFunctions = nondet_int,sscanf,random,ldv_undef_ptr,ldv_undef_int,ldv_undef_ulong
cpa.predicate.trackFunctionPointers = false
# cpa.predicate.abstraction.computation = CARTESIAN
cpa.predicate.checkBlockFeasibility = true
cpa.predicate.targetStateSatCheck = true

limits.time.cpu = 900s

output.disable = true

specification = specification/sv-comp-reachability.spc
statistics.memory = false

# Options related to scope-bounded verification start here VVVVVV >>>

analysis.stubPostfix=___stub
analysis.stubs=true
cpa.scopebounded.stubPostfix=___stub

cpa.predicate.useMemoryRegions = true

cpa.predicate.blk.stubPostfix=___stub

cpa.predicate.havocRegionFunctionName=__VERIFIER_havoc_region

cpa.predicate.chooseFunctionName=__VERIFIER_choose

cpa.predicate.enablePureStructOptimization=false

cpa.value.abstraction.stubPostfix=___stub

cpa.value.havocRegionFunctionName=__VERIFIER_havoc_region

# cpa.predicate.merge=SEP
# cpa.predicate.stop=SEPPCC

# cpa.value.abstraction.alwaysAtFunction = true
# cpa.value.abstraction.alwaysAtLoop = true
# precision.variableBlacklist=.*

cpa.scopebounded.refiner.edgeIncrement = 0
cpa.scopebounded.refiner.maxUnrollFraction = 1

cpa.predicate.encodeBitvectorAs=INTEGER
solver.solver=SMTINTERPOL
solver.interpolationSolver=SMTINTERPOL

cpa.predicate.useArraysForHeap = true
cpa.predicate.allocFunctionName=malloc
